# 알고리즘

1. minimal spanning tree 에 대해서 설명하시오

   * spanning tree 는 그래프의 간선의 수가 가장 적은 연결 그래프 이다. 대신 이 엣지들에 사이클이 존재하면 안된다. (그래프의 최소 연결 부분 그래프)

   * n개의 엣지가 있는 그래프의 최소 간선의 수는 (n-1)개 이고, (n-1)개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 바로 spanning tree이다.

   * 모든 정점들이 연결 되어 있고, 사이클이 포함되어서는 안된다.
   * 그 중에서 minimal spanning tree 라는 것은 spanning tree에서 간선들의 가중치의 합이 최소인 트리를 말한다. 이 과정은 통신망, 도로망 등의 구축, 전송 시간 등등을 최소로 구출하려 할 때 사용되어질 수 있다.

2. 크루스칼(Kruskal) 알고리즘에 대해 설명하시오.

   * 탐욕적인 방법을 이용한 것으로, 각 단계에서 사이클을 이루게 되지 않는 최소 비용의 간선 부터 차근차근 선택하는 방식이다.
   * 그래프의 간선들을 가중치의 오름차순으로 정렬하고, 정렬된 리스트에서 가장 낮은 가중치를 먼저 선택하고, 그 가중치의 간선이 사이클을 이루지 않는지(간선 양끝의 노드가 모두 이미 선택되지 않았는지)확인 후에 적합하면 그 간선을 선택해나간다. 이렇게, n-1개의 간선이 선택될 때 까지 반복한다.

3. Prime MST 알고리즘에 대해 설명하시오.

   * 시작 정점으로부터 신장트리 집합을 단계적으로 확장해나가는 방법이다.
   * 처음에 한 정점으로 시작을 하고, 이 정점이 연결된 간선들 중에서 가장 최소의 가중치로 연결된 노드를 다음 노드로 선택하는데, 그 다음 노드가 이미 이전에 선택된 이력이 있으면 그 다음으로 큰 가중치를 가지는 애를 다음 노드로 설정하는 식으로 사이클을 이루지 않는 최소한의 가중치를 가지는 노드들을 추가해나간다. 이렇게, n-1개의 간선이 선택될 때 까지 반복한다.

4. 크루스칼의 알고리즘을 사용하려고 하는데, 최대값 가중치를 가지는 edge 부터 제거해서 MST 가 남을때까지 하고 싶다면 가능할까요? 왜 그렇게 생각해요?

   * 기존의 알고리즘으로는 불가능할 것 같습니다. 왜냐하면 싸이클을 피할 수 없게 되기 때문입니다. 최대값 부터 지워나가면 제일 최소 값들의 간선만 선택이 되는데, 제일 최소 값들의 간선만 선택을 하면 사이클 유무에 대한 검사가 진행된 상태가 아니기 때문입니다.

5. BST란?

   * Binary Search Tree 로 각 노드의 왼쪽 서브 트리에는 해당 노드의 값보다 작은 값을 지닌 노드를, 오른쪽은 더 큰 노드를 배치하는 트리 이다. 이 트리를 이용하면 탐색에 걸리는 계산 복잡성은 트리의 높이와 관계가 있다. O(높이) 즉 -> O(log2(N+1))

6. BST 에서 worst case 는 무엇인가? 또 그것을 해결하려면 어떻게 해야하나

   - 가장 최악은 트리가 한 방향으로만 배치되어 있는 경우 입니다.
   - 이를 해결 하기 위해 균형 트리를 사용합니다. (AVL tree, B-tree)

7. 균형 트리를 recursive definition 으로 표현해보시오

8. B-Tree 를 쓰는 이유는? 무엇이 효율적인가

9. AVL tree 로 어떻게 변형하는지 과정을 자세히 말해보시오

   <img src="/Users/mcnl/Interview_for_developer/images/AVL-tree.png" alt="AVL-tree" style="zoom:70%;" />

   * AVL 트리는 각 노드에서 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1를 넘지 않도록 유지하는 트리 이다. 즉, 균형 인수(왼쪽 서브 트리 높이에서 오른쪽 서브 트리 높이를 뺀 값)는 -1,0,1, 중 하나여야만 한다.
   * 자료 삭제 혹은 삽입시, AVL 균형이 무너지지 않도록 트리 구조의 재배치를 통해 BF(균형 인수)값을 -1,0,1 의 값으로 조정시켜 준다.
   * 조정 과정은 4가지 단계로 이루어 진다.
     * LL 왼쪽으로만 높이가 2이상 높은 경우 -> Right Rotation 수행
     * RR -> LL과 반대
     * LR 왼쪽 서브트리가 높이가 1더 높은데, 왼쪽 서브트리의 오른쪽 때문에 차이가 있는 경우 -> Left Rotation 수행 후(LL 모양이 되도록), Right Rotation실행
     * RL -> LR 과 반대
   * 균형 유지로 일정 수준의 검색 성능을 보장하지만 자료의 개수 증가로 트리의 높이가 계속해서 높아진다는 문제점이 존재한다. 그리고, 자료의 추가나 삭제가 빈번하게 발생하면 오버헤드가 커진다.

10. 그래프가 있을때 어떤 정점에서 어떤 정점까지의 최단거리를 구하려고 할 때 어떤 알고리즘을 쓸 것인가?

    * 다익스트라 알고리즘 

      * 한 점에서 모든 점까지 최단 거리를 구하는데, 가중치가 양수일 때만 사용한다. 
      * 다이나믹 프로그래밍의 일종이다. 왜냐하면, 현재 정점에 이전 정점까지의 최단 거리에서 현재 정점으로 가는 최소의 가중치를 더해나가기 때문이다.
      * 과정은, 출발 노드를 설정하고 그 노드가 닿을 수 있는 다음 노드들에 해당 가중치를 저장한다. 그 연결된 간선중 가장 작은 간선으로 연결된 노드를 다음 노드로 설정한다. 그 다음 노드에서 또 연결된 간선들을 이용해서, 해당 노드에 오기 까지의 가중치와 그 간선이 연결된 그 다음 다음 노드에 가기 까지의 가중치를 더하고, 그 더한 값이, 현재 그 다음 다음 노드에 저장된 거리 값보다 작으면 그 더한 값으로 업데이트 해줍니다. 이런 식으로 과정을 반복하여 노드들을 모두 검색합니다.

    * 플로이드 와샬 알고리즘

      * 모든 정점에서 모든 정점으로의 최단 경로를 구하고 싶을 때 사용하는 알고리즘 -> 거쳐가는 정점을 기준으로 알고리즘을 수행, 이 알고리즘 또한 다이나믹 프로그래밍을 기초로 둔다.
      * i 에서 j 로 가는 최소 비용 > i에서 k로 갔다가 j로 가는 최소 비용을 비교

      ```c++
      for(int k=0; k<number; k++){
        for(int i=0; i<number; i++){
          for(int j=0; j<number; j++){
            if(d[i][k]+d[k][j]<d[i][j]){
              d[i][j]=d[i][k]+d[k][j]
            }
          }
        }
      }
      ```

      

11. 플로이드 알고리즘이랑 다익스트라랑 시간복잡도 비교해봐. 뭐가 더 좋을까? 그럼 어느 상황에서 무슨 알고리즘이 유리할지 수식이나 정확힌 기준을 적어봐. 

12. sorting 배운것들 중에 뭐가 unstable sort인지 stable sort인지 말해봐. 

13. 





# 참고

9. https://m.blog.naver.com/PostView.nhn?blogId=qbxlvnf11&logNo=221371740002&proxyReferer=https:%2F%2Fwww.google.com%2F