# 자료구조

: '비교'를 중심으로 공부를 하는 것이 가장 좋음

- Array / LinkedList
- Stack / Queue
- HashSet / HashMap / HashTable / Dictionary
- Tree / Binary tree
- Heap
- Graph

![스크린샷 2020-03-16 오후 11.38.10](./images/dataStructure.png)

1. 자료구조 라이브러리를 많이 사용해 보았는가?

   다양한 라이브러리 구조를 사용해 본 경험이 있다. 여러 프로젝트를 진행하면서 Java나 c등 내장된 자료구조 STL을 사용하였다. 웹 개발 할때, 데이터 베이스에 담긴 내용들을 한꺼번에 select할때, ArrayList에 담는 등 때에 따라 리스트 형태를 사용하기도 하고 map형태를 사용하기도 하면서, 다양한 자료구조의 쓰임을 이해해왔다. 또한, 알고리즘 공부를 하고 문제를 풀면서 다양한 자료구조를 이용했다.
   또한, 파이썬에서 thread를 운용할때, 공유되는 데이터의 효율적 사용을 위해 queue구조를 사용하여 순차적 처리가 가능하도록 하였다.

2. 배열 (Array) vs 배열 리스트 (ArrayList) vs연결 리스트 (LinkedList)

   - 배열은 메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하며 데이터를 자체로 순차적으로 메모리에 올린 것이다. 
     다수의 데이터를 순차적으로 접근할 수 있고, 랜덤 접근(random access)가 가능하기 때문에 자료를 검색하는 것에 매우 효과적이다. 하지만, 데이터가 연속되어 있을 때, 데이터를 삽입하거나 삭제를 하면, 다른 데이터들의 저장 주소를 모두 옮겨야하는 비효율이 존재한다. 

   - 이를 해결하기 위해 나온 것이 List이다. List는 array 처럼 크기를 처음에 정해주지 않아도 된다. 따라서 중간에 데이터를 삭제 및 추가 하여도 array에서의 비효율을 해결할 수 있다. ArrayList 의 경우에는 index를 가지고 있으므로 검색도 빠르다. 하지만 ArrayList 는 LinkedList 에 비해 추가,삭제의 시간이 오래걸린다.

   - 반면, 연결리스트는 각각의 데이터를 포인터로 순서를 유지시키는 자료구조 이다. 이는 포인터만 끊어 주거나 변경해주면 되기 때문에 삽입과 삭제가 매우 효율적으로 동작하는 구조이다. 대신에, 어떤 index에 접근하기 위해 처음 index부터 순차적으로 접근해야 하기 때문에 검색이 조금 더 오래걸리는 단점이 있다.

   - 하지만, 추가적으로 연결 리스트 자료구조는 search 에 O(n)의 시간 복잡도(time complexity)를 갖는데, 삽입과 삭제 과정에서도 어떤 특정 원소를 찾아야 하기 때문에 O(n)의 시간이 추가적으로 발생하게 된다는 사실이 있다. 따라서, 검색,삽입,삭제에 O(n)의 시간 복잡도를 가진다는 것이다. 그렇지만, LinkedList는 tree구조의 근간이 되며, Tree에서 사용되었을 때 유용성이 드러난다.
     


4. Stack vs Queue

   스택은 LIFO 구조로 나중에 들어간 것이 먼저 나옵니다. 이는 괄호 합 판단이나, -> 내부 메모리 구조가 기본적으로 스택 형태 -> 재귀 함수, 스택처럼 단계적으로 쌓여서 차례대로 먼저 해결되는 방식

   큐는 FIFO 구조로 우선순위 큐 형태로 많이 사용되고 있고, 다익스트라 알고리즘 처럼 최단경로 알고리즘에도 쓰이고, 운영체제나 다양한 생산 공정 등에도 쓰이고 있음
   

5. Heap

   완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 구조, 여러 개의 값들 중에서 최댓값(Max heap)이나 최솟값(Min heap)을 빠르게 찾아내도록 만들어진 자료구조이다.

   Max heap의 경우에는 부모 노드의 키 값이 자식 노드의 키 값 보다 큰 이진 트리이다.
   
   [Heap 구현 with Java](./code/Heap.java)
   
   **Q1) Heap 이 무엇인가?**
   
   완전 이진 트리의 일종으로 우선순위 큐를 구현하기 위한 한 방법, 맥스 힙과 민 힙으로 구분된다. 맥스힙은 그 노드의 자식보다 부모가 더 큰 형태, 일종의 트리 형태, 여기서 root값이 가장 최대 값이 되므로, 그 데이터에서 root를 하나씩 뽑아내면 이미 내림차순으로 정렬이된 배열을 뽑아낼 수 있다. -> 우선 순위 큐를 만들 수 있는 방법 중 하나 -> 이 개념을 이용한 것이 heap 정렬이다.
   
   최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조이다.
   
   ```sh
   왼쪽 자식 index = (부모 index) * 2
   
   오른쪽 자식 index = (부모 index) * 2 + 1
   
   부모 index = (자식 index) / 2
   ```
   
   
   
6. 우선순위큐 (priority queue)

   - FIFO의 큐에 개념에서, 우선순위를 더해서 우선순위가 높은 것이 먼저 처리되는 큐
     주로 heap구조에 기반하여 구현한다. 이진 트리의 형식으로 우선순위가 가장 높은 데이터가 root에 자리하게 된다. 

   - 새로운 데이터가 들어오면 일단, 이진트리가 유지되는 제일 마지막 위치에 삽입하고, 그 데이터의 부모 노드들과 우선순위를 비교하여 더 높으면 부모 노드와 자리를 바꾸고 그렇지 않으면 자리를 그대로 유지한다.

   - 삭제 기능은 우선순위가 가장 높은 데이터 부터 삭제하므로 루트 자리에 있는 데이터가 삭제가 되고, 그 후에 조건 유지를 위해 가장 마지막 데이터를 루트로 올린 후 자식 노드와 비교하면서 제자리를 찾게된다.
     

7. Hash Table

   > 연관 배열(associative array) 구조 이용
   >
   > 연관 배열 이란? 키와 값이 1:1로 연관되는 자료구조

   - Hash Table 은 key,value,hash function,hash,bucket(저장소) 으로 이루어진 자료구조로 key 값을 hash function에 넣어서 일정한 길이의 hash값으로 변경하고 이에 대응되는 메모리 공간(bucket)에 value를 저장하는 구조이다.

   <img src="./images/hash.png" alt="hash" style="zoom:50%;" />

   - 하지만 무한한 길이(제각각의 길이)의 key값을 정적인 유한한 길이의 hash값으로 만드는 과정에서 당연히 충돌이 나타날 수 밖에 없다. 이 문제를 hash collision문제라고 한다. 
     삽입,삭제,검색 시간복잡도 big O : O(1)   but hash collision -> O(n)
     hash collision을 해결하기 위한 방법 대표적인 2가지 : 
     - (1) chaining
       * 충돌되는 데이터들을 연결 리스트로 묶기
     - (2) open addressing
       * 비어있는 해시에 충돌값 저장하기
   - 충돌 문제가 있는대도 해시 테이블을 쓰는 이유는?
     - 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해
     - 하드디스크나 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해짐
       
   
8. Binary search tree 를 Inorder travel 을 이용하여 순서대로 나열하면 크기순(오름차순)으로 나열되는가?

   <img src="./images/inorder_traversal.jpg" alt="inorder_traversal" style="zoom:80%;" />

   - Binary search tree는 부모노드의 왼쪽 자식은 부모노드 이하의 크기고, 오른쪽 자식노드는 부모노드 이상의 크기다. 따라서 가운데 노드가 제일 중간에 방문되는 inorder travel을 이용하면, 위 트리가 D B E A F C G 와 같이 방문이 되는데, 이는 항상 더 작은 왼쪽에 있는 노드가 방문이 되고 가장 큰 노드가 나중에 방문이 되는 것이다.
     
   
9. Trie (트라이)

   > 문자열에서 검색을 빠르게 도와주는 자료구조
   > 참고 코드 : https://mishuni.tistory.com/46?category=844894

10. 

## 출처

이미지 : https://www.bigocheatsheet.com/

[Github: Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/)

[Tistroy: 기본 정렬 알고리즘](https://hsp1116.tistory.com/33)

[Tistroy: Counting Sort](https://bowbowbow.tistory.com/8)

[Tistroy: Sorting Algorithm 을 비판적으로 바라보자](http://asfirstalways.tistory.com/338)

[Tistory: [자료구조] 우선순위 큐(Priority Queue) -1](https://hannom.tistory.com/36)

[Velog: Hash, Hashing, Hash Table 자료 구조의 이해]([https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table해시-해싱-해시테이블-자료구조의-이해-6ijyonph6o))

