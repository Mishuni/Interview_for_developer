# 논리회로 / 컴퓨터구조

1. 아키텍쳐가 무엇인가
   (1) 시스템 아키텍처

   - 시스템 아키텍처란 시스템의 개념적 모형이다. 시스템의 목적을 달성하기 위해 각 구성 요소가 무엇이며 어떻게 상호작용하고 정보가 어떻게 교환되는 지를 계획하고 설명한다.
   - 시스템 전체(하드웨어와 소프트웨어를 포괄한 것)에 대한 논리적인 기능 체계와 그것을 실현하기 위한 구성 방식. 시스템의 전체적인 최적화를 목표로 하고 있다.

   (2) 컴퓨터 아키텍처 (컴퓨터 구조)

   * 컴퓨터 시스템의 기능(functionality), 조직(organization), 구현(implementation)에 대한 법칙과 방법
   * 컴퓨터 구조는 [명령어 집합 구조](https://ko.wikipedia.org/wiki/명령어_집합)(Instruction set architecture, ISA), [마이크로아키텍처](https://ko.wikipedia.org/wiki/마이크로아키텍처)(Microarchitecture) 설계, 논리 설계 및 구현

2. 폰 노이만과 하버드 아키텍쳐에 대해서 설명하시오

   <img src=".\images\architecture.jpg" alt="architecture" style="zoom:100%;" />

   - 폰 노이만 구조 : 
     - 이름 그대로 존 폰 노이만이 고안한 내장 메모리 순차처리 방식이다. 데이터 메모리와 프로그램 메모리가 구분되어 있지 않고 하나의 버스를 가지고 있는 구조를 말한다. 이 구조에서 CPU는 메모리로부터 명령을 읽고, 메모리로부터 데이터를 읽고 쓰기도 한다. 명령과 데이터는 같은 신호 버스와 메모리를 사용하기 때문에 동시에 접근하는 것은 불가능하다. (명령어를 읽을 때 데이터를 읽거나 쓸 수 없다.)
     - 폰 노이만 구조의 디지털 컴퓨터에서는 ‘저장된 프로그램’(stored-program)의 개념이 도입되었다. 이는 프로그램을 구성하는 명령어들을 임의 접근이 가능한 메모리상에 순차적으로 배열하고, 동시에 조건 분기를 무제한적으로 허용한다는 것을 뜻한다. 폰 노이만 구조에서는 같은 메모리 속에 실행코드와 데이터가 따로 구분되지 않고 함께 섞여 있다.
     - **폰 노이만 병목현상**
       - 내장 메모리 순차처리 방식으로, 데이터 메모리와 프로그램 메모리가 구분되어 있지 않고 하나의 버스를 가지고 있는 구조 때문에 CPU가 명령어와 데이터에 동시 접근할 수 없습니다. 이를 해결하고자 나타난 구조가 하버드 구조입니다.
       - 또한 메모리의 값을 읽고 쓰는 구조이기 때문에 기억장치에 병목현상이 생길 수 밖에 없습니다. 이를 해결하고자 나타난 기술에는 메모리 계층 구조나 NUMA, DMA 등이 있습니다.
   - 하버드 구조 :
     - 하버드 아키텍처(Harvard architecture)는 본래 명령용 버스와 데이터용 버스로 물리적으로 분할한 컴퓨터 아키텍처를 나타내는 용어입니다 (폰 노이만 구조와 대비시킨 용어이기도 합니다).
     - 폰노이만 구조에서는 CPU가 명령어와 데이터에 동시에 접근이 불가능해서 한번에 하나씩 처리할 수 없었던 반면에, 하버드 아키텍처의 컴퓨터에서는 명령을 메모리로부터 읽는 것과 데이터를 메모리로부터 읽는 것을 동시에 할 수 있습니다. 따라서 현재 명령의 처리를 끝내는 동시에 다음 명령을 읽어 들일 수 있어서 더 빠른 속도를 낼 수 있습니다.
     - 그렇지만 이러한 처리 속도를 높이려면 보다 많은 전기 회로가 필요합니다. 두개의 버스와 메모리를 가지게 되므로 CPU코어에서 공간을 많이 차지합니다.
   - 현대에 이르러서는 CPU의 외부적으로는 폰 노이만 구조를, 내부적으로는 하버드 구조를 적용하여 속도를 향상시킨 것이 많습니다. 그러나 이것 또한 폰노이만 구조를 기반으로 만들어진 것이기 때문에, 병목현상만 어느 정도 해결할 뿐 메모리 속의 프로그램을 순차적으로 실행하는 근본적인 구조 자체는 변하지 않습니다.

3. 데이터랑 명령어가 메모리를 공유하면 좋은 점이 무엇인가? 한개의 버스와 메모리를 가지므로 cpu 공간 차지가 적다, 또한 하버드 구조보다야 적은 회로가 필요하다.

4. 파이프라이닝이란?

   * 명령어를 순차적으로 실행하는 프로세서에 적용되는 기술로, 한 번에 하나의 명령어만 실행하는 것이 아닌 하나의 명령어가 실행되는 도중에 다른 명령어를 실행을 시작하는 식으로 동시에 여러 개의 명령어를 실행하는 기법
   * 동시에 여러개의 명령어를 처리하므로써 처리량을 올리는 것이지 각 명령어의 실행시간을 개선하지는 못한다.
   * 명령어를 세분화 할수록 처리 속도의 향상을 기대할 수 있지만, 실행할 명령 수에 비해 지나치게 단계를 세분화 하면 높은 효율성을 기대하기는 힘들다.

5. 슈퍼스칼라란?

   - 클록에 대한 throughput을 최대화하기 위해서 쓰입니다. 슈퍼 스칼라가 일반 파이프라이닝보다 더 많은 명령어를 처리할 수 있죠.
   - 슈퍼파이프라이닝은 파이프라이닝의 깊이를 증가시켜 더욱 많은 명령어를 중첩시키는 것, 슈퍼스칼라 파이프라이닝은 파이프라인을 여러 개 복제하여 사이클마다 다수의 명령어를 파이프라인에 투입하는 것.

6. 파이프라이닝을 단계를 늘리면 그만큼 빨라지는가?

   * 명령어를 세분화 할수록 처리 속도의 향상을 기대할 수 있지만, 실행할 명령 수에 비해 지나치게 단계를 세분화 하면 높은 효율성을 기대하기는 힘들다.

   * 해저드라는게 있는데 스트럭쳐럴 해저드, 데이터 해저드, 컨트롤 해저드 때문에 성능이 막 오르지는 않습니다.

7. 3가지 해저드를 각각 어떻게 해결하는가?

   * 구조적 해저드 : 프로세서의 자원이 부족해서 발생

     > 파이프라인에서 실행 중인 2개 이상의 명령어가 동일한 하드웨어 자원을 동시에 요구하기 때문에 파이프라인을 멈춰야 하는 상황

     | 클럭주기 | 1        | 2        | 3        | 4           | 5           | 6        | 7        |
     | -------- | -------- | -------- | -------- | ----------- | ----------- | -------- | -------- |
     | 명령어 1 | 가져오기 | 해석하기 | 실행하기 | 결과쓰기    |             |          |          |
     | 명령어 2 |          | 가져오기 | 해석하기 | 실행하기(1) | 실행하기(2) | 결과쓰기 |          |
     | 명령어 3 |          |          | 가져오기 | 해석하기    | 실행하기    | stall    | 결과쓰기 |
     | 명령어 4 |          |          |          | 가져오기    | stall       | 실행하기 | Stall    |

     위와 같이 명령어 2에서 실행하기가 한 클럭에 안 끝나는 경우, 명령어 3에서 결과쓰기를 수행할 때 멈춤(stall)이 발생한다.

     명령어 4에서는 해석하기 단계가 필요없는 명령어 이므로, 실행하기를 수행할 시 명령어 3에서 실행하기가 수행되고 있어 또한 멈춤이 발생한다.

     **해결 방안**: 충돌하는 자원을 추가로 제공하여 파이프라인을 재구성하거나, 예약표(Reservation table)을 이용하여 자원 충돌을 방지. 만약 레지스터 파일이나 메모리에서 충돌이 발생하면 읽기나 쓰기가 동시에 처리될 수 있도록 다중 포트화(multi-port)하거나 둘 이상으로 분할함으로써 구조적 해저드를 일부 해소

   * 데이터 해저드 : **이전 명령어의 결과를 기반으로 다음 명령이 수행될 때 파이프라인이 지연되는 경우 생기는 것**으로, 컴퓨터 파이프라인에서는 앞선 명령어에 종속성을 가질 때 데이터 해저드가 일어난다.

     > 연산할 데이터가 준비되지 않아 파이프라인을 멈춰야 하는 모든 상황이나 조건, 주로 선행 명령어가 사용하는 데이터와 후행 명령어가 사용하는 데이터 사이의 종속 관계로 인해 발생하므로 데이터 종속이라고도 한다.

     **해결 방안**:  **전방전달(forwarding)** 혹은 **우회전달(bypassing)**

     - 이것은 별도의 하드웨어를 추가하여 정상적으로는 얻을 수 없는 값을 내부 자원으로부터 일찍 받아오는 것을 의미하는데, 레지스터나 메모리에 아직 나타나지 않은 데이터를 기다리지 않고 데이터패스를 추가로 하드웨어에 연결하여 내부 버퍼로 부터 가져오는 것이다.(전방전달)-> 예로 쓰기 후 읽기 (RAW) 의 경우 ALU 에서 연산 완료된 값이 $1에 저장이 되는데 이를 바로 다음 명령어에서 읽고 사용해야 하는 경우, write 전에 ALU 에서 연산 완료된 값을 가지고 오는 것

     - 결과를 생성하는 파이프의 출력과 결과를 사용하는 파이프의 입력을 연결하는 별도의 경로를 추가하면 되는데, 이와같은 기법을 전방 전달 / 컴파일러의 도움으로 적재 명령어의 결과와 무관한 명령어의 순서를 바꾸는 기법을 지연적재라고 한다.

   * 제어 해저드 : 명령어의 실행 순서를 변경하는 Branch , Jump 등 **분기 명령어들로 인해 다른 명령어들이 실행 중에 한 명령어의 결과 값에 기반을 둔 결정을 할 필요**가 있을 때 일어난다.

     > 행할 명령어가 결정되지 않았거나 준비되지 않아서 파이프라인을 멈춰야하는 상황이나 조건

     | 클럭주기 | 1        | 2        | 3        | 4        | 5        | 6        | 7        |
     | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
     | 명령어 1 | 가져오기 | 해석하기 | 실행하기 | 결과쓰기 |          |          |          |
     | 명령어 2 |          | stall    | Stall    | 가져오기 | 해석하기 | 실행하기 | 결과쓰기 |

     **해결 방안** :

     - Delayed Decision : 손실되는 클럭 동안 프로그램에 영향이 없는 다른 명령어 실행
     - Predict Taken / Not Taken : 명령어 분기를 예측하여 명령어 수행 / 명령어 분기 시 명령 취소 
     - Stall : 분기 방향이 결정될 때 까지 지연

   * 파이프라인 해저드는 해저드의 원인이 사라질 때까지 파이프라인에의 명령어 투입을 멈춰야 하는데 이를 파이프라인 중지(pipeline stall) 또는 파이프라인 버블 이라고 한다. 파이프라인 버블이 많아지면 성능향상에 방해가 되기 때문에 이를 위한 다양한 해결책이 필요하다. 소프트웨어적으로는 컴파일러의 도움으로 명령어의 순서를 변경하는 방법이 있고, 하드웨어적으로는 파이프라인을 다시 설계하거나 하드웨어 자원을 추가함으로써 파이프라인 버블을 해결할 수 있다.

8. 캐시를 사용하는 이유는?

9. 페이지 테이블은 어디에 있는가?

10. 페이지 테이블에 접근하는 시간을 줄이기 위해 어떻게 하는가?

11. 밀리머신과 무어머신의 차이
    - 밀리 : 출력이 상태와 입력에 따라 다름
    - 무어 : 출력이 상태의 따라 다름

12. 논리식 간소화 방법 (카르노맵)

13. 페이지 폴트나면 어떻게 하는가?

14. 메모리를 기억하는 소자에는 무엇이 있나?

15. Virtual memory 가 무엇인가?

16. page fault 나면 page replacement 할 때 기억해야 되는 정보들이 뭐냐 그냥 바꿔주면 되냐

17. 메모리 하이러키에 대해서 설명해봐.

18. locality에는 어떤게 있지?

19. 멀티 코어 프로세스하고 멀티 쓰레드 프로세스 알아? 그러면 캐시는 어떻게 해?

    - 캐시는 두 코어가 공유하는게 있고 각각이 또 따로 가지고 있습니다.

20. 



# 출처

7. https://happy-coding-day.tistory.com/49 , https://jokerkwu.tistory.com/120, http://blog.skby.net/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%ED%95%B4%EC%A0%80%EB%93%9C-%EB%B0%8F-%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%95%88/