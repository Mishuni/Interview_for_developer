# OS (운영체제)

1. Interpreter 와 compile 언어에 대해 설명하시오 

* **인터프리터 언어**는 프로그래머가 작성한 소스코드(원시코드)를 바로 기계어로 변환하는 과정없이 한 줄씩 해석하여 명령어를 실행하는 언어이다. R, Python, Ruby와 같은 언어들이 대표적이다.

  인터프리터가 직접 한 줄씩 읽고서 기계어로 따로 변환하지 않기 때문에 빌드 시간이 없다. Runtime 상황에서는 한 줄씩 실시간으로 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다.

  실행 속도가 느리지만, 코드 변경 시에 빌드 과정이 없이 바로 프로그램을 실행하는 장점이 있습니다.

 

* **컴파일 언어**는 프로그래머가 작성한 코드를 모두 한꺼번에 기계어로 변환한 후에 기계(JVM 같은 가상 머신)에 넣고 기계어 코드를 실행합니다. C와 Java가 대표적이다.

  이런 변환 과정을 빌드 과정이라고 하고, 이 때문에 인터프리터 언어에 비해 실행에 시간이 소요가 됩니다. 

  하지만, 런타임 상황에서는 이미 기계어로 모든 소스코드가 변환 되어 있기 때문에 빠르게 실행할 수 있습니다. 

 

> **런타임**이란? 컴퓨터 프로그램이 실행되고 있는 동안의 동작. 

> 즉, 컴퓨터 내에서 프로그래밍이 기동 되면, 그것이 바로 프로그램의 런타임이다.

> 어떻게 보면, 프로그래밍 언어가 구동되는 환경이라고 이해할 수도 있다.

> 예로, JavaScript 라면 Web Browser에서 작동하는 JavaScript 측면이 있고,

> Node.js라는 환경에서 구동되는 측면도 있다. 여기에서의 Browser와 Node.js를 런타임이라고 볼 수 있다.

 

2. Process 와 Thread에 대해 설명하고, 둘의 차이를 설명하시오

* **프로세스**는 운영체제가 메모리 등의 필요한 자원을 할당한 실행중인 프로그램을 뜻한다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 따라서, 다른 프로세스의 메모리에 접근하려면 IPC(Inter Process Communication)과 같은 방식이 필요하다. 

> **Multiprocessing** : 여러 개의 프로세스를 동시에 처리하는 것, Task를 실행하는 core (CPU core, processor) 가 2개 이상인 경우 (동시에 여러가지 일을 수행할 수 있을 때)

> **Multitasking** : 동시간에 여러 개의 프로그램을 띄우는 것, 하나의 core가 시분할(time slicing) 기법을 이용해서 여러 개의 Task를 마치 동시에 수행되는 것처럼 보이게 하는 기법



* **스레드**는 프로세스 내에서 실행되는 각각의 일을 말한다. 결국, 프로세스 내에서 실행되는 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다. 

  스레드는, 프로세스 내에서 그 프로세스의 자원을 이용해서 실제로 작업을 한다. 따라서, 스레드가 포함된 프로세스가 운영체제로부터 자원을 할당 받으면 그 자원을 사용하여 작업을 처리한다.

  각 스레드는 독자적인 Stack메모리를 갖는다. 스레드는 메모리를 공유하기 때문에, 동기화(synchronize) 및 데드락의(Deadlock) 문제가 발생 할 수 있다.

 

> **Multithread** : 프로세스가 둘 이상의 스레드를 가지고 일을 수행하는 것, 하나의 Task를 여러 개의 sub Task로 분할해서 동시간에 실행되는 것처럼 수행하는 기법

> 예로, 1부터 1000까지 더하는 작업의 경우, 단일 스레드(single thread)는 순차적으로 일을 처리하므로, 1부터 1000까지 더하는 작업이 진행될 동안, 이와 독립적은 다음 작업을 실행할 수가 없다. 따라서, 더하는 작업을 multithread방식으로 구현하면, 1~1000까지 더하는 작업과 동시에 다음 작업을 진행할 수 있다.

 

* 결국 **process 와 thread의 가장 중요한 차이**는 자원을 공유하는 방식에 있다.

  프로세스는 운영체제로부터 자원을 할당 받는다. 따라서, 각 작업(Task)마다 운영체제로부터 자원을 할당 받기 위해 시스템 콜(call)을 하는 부담이 존재한다. 이 상황에서, 멀티스레드는 시스템 콜(call)을 한번만 해도 되기 때문에 효율적이다. 한 process 내에서 자원을 공유하는 것이기 때문이다. 

  또한, IPC 방식보다는 스레드 간 통신이 덜 복잡하고 시스템 자원 사용이 더 적다. 따라서 통신의 부담이 더 적다. 하지만, 멀티스레드 방식은 동기화 작업을 따로 해줘야 하기 때문에 제어가 어렵다는 단점이 존재한다.

  **멀티 프로세스 구조**에서 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 자식 프로세스 하나만 죽는다 해서 다른 곳에 영향을 끼치지는 않는다.

  **멀티 스레드 구조**에서는 자식 스레드 중 하나에 문제가 생긴 경우에는 전체 프로세스가 영향을 받게 된다.(ex : thread I/O)

  

3. Deadlock과 Starvation에 대해서 설명하시오

* 데드락은 프로세스가 자원을 얻지 못해서, 다음 작업을 처리하지 못하는 생태입니다. 이는 시스템적으로 한정된 자원을 여러 곳에서 동시에 사용하려고 할 때 발생합니다.

  주로, 멀티프로세스나 멀티스레드 환경에서 여러 프로세스나 스레드들이 한정된 자원을 공유하여 사용하기 때문에 발생합니다.

  예로, A라는 프로세스가 B가 가진 자원이 있어야 동작이 가능해서 B의 작업이 끝나서 자원을 넘겨주기를 기다리고 있다. 근데, 동시에 B라는 프로세스 역시 A가 가진 자원이 있어야 해서 A의 작업이 끝나기를 기다리고 있는 상태면, 무한 교착 상태에 빠진다. ( A와 B 작업 모두 끝이 날 수 없다. ) -> 서로 상대방의 작업 끝나기만을 기다리는 상태

* 데드락 발생 조건 4가지

  1)   **상호 배제 (Mutual Exclusion, Mutex)** : 공유 불가능한 자원의 동시 사용을 피하기 위해 사용되는 로직, 임계 구역(critical section)으로 불리는 코드 영역에 의해 구현된다. 즉, 공유 자원을 어느 시점에서 오직 한 개의 프로세스만이 사용할 수 있도록 하는 조건

  2)   **점유 대기 (Hold and Wait)** : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 요청하고 기다리는 것

  3)   **비선점 (No preemption)** : 프로세스가 어떤 자원의 사용을 끝낼 때까지 다른 프로세스가 그 자원을 뺏을 수 없는 것

  4)   **순환 대기 (Circular wait)** : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있는 형태 

> 기아상태(starvation)은 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태를 말한다.

> 교착상태는 여러 프로세스가 동일 자원의 점유를 요청할 때 발생하고, 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원이 할당이 안되는 경우를 의미한다.

 

4. Thread 들이 자원을 어떻게 공유하는지 설명하시오

* 멀티스레드 방식에서 만나게 되는 문제는 동기화(Synchronization)다. 왜냐하면, 스레드는 별도로 실행되는 하나의 실행이므로 동시에 여러 스레드가 진행되면 스레드들이 공유하는 자원이 동기화된 상태로 공유될 수 없기 때문이다. 만약, 각 스레드들이 서로가 침범하는 영역이 없다면 동기화 문제를 고려하지 않아도 된다.

  프로세스들 간에는 이미 OS가 별도의 프로그램으로 잘 동작하도록 알아서 처리를 해주고 있다. 왜냐하면, 프로세스는 자신만의 메모리 영역이 존재하고, 다른 프로세스의 메모리 영역을 침범할 수가 없기 때문이다. 하지만, 한 프로세스 안에서 실행되는 여러 개의 스레드들은 서로 공유할 수 있는 메모리 부분이 있다. 그래서 동기화 문제가 발생한다.

> Ex) 10만원이 있는 한 계좌에서 A가 10만원을 뺏고, ATM기기가 계좌 잔고를 0원으로 바꾸려고 할 때, interrupt 가 걸린 상태에서, B가 다른 기기에서 동일 계좌로부터 10만원을 빼려고 할 때, 잔고 부족으로 안되어야 하는데 동기화 작용을 안하면 10만원이 남은 줄 알고 돈이 빠진다.
>
> Race Condition : 이렇게 두 개 이상의 스레드들이 하나의 자원을 이용하려 경쟁하는 상황을 뜻

 

* 동기화 문제는 스레드들간의 공유 자원에 접근하는 것을 한번에 한 스레드만 가능하게 함으로써(상호 배제, Mutual Exclusion) 해결할 수 있다. 

> 한 번에 하나의 스레드만 임계 영역(critical section)에 있는 객체에 접근할 수 있도록 객체에 락(lock)을 걸어서 데이터의 일관성을 유지

> **lock 방식** 뿐 아니라 동기화 문제를 해결하기 위한 방법으로 **semaphore, monitor** 등이 있다. 

 

5. Semaphore(세마포)에 대해서 설명하시오

* ‘깃발’ 이라는 뜻으로, 옛날 기찻길에서 빨간색 깃발이면 멈추고, 파란색이면 지나가도 되는 표시를 했던 걸 말한다. s/w 적으로는 임계 영역(critical section)이 기찻길이고, 공유 자원의 사용 가능 여부를 semaphore가 나타낸다. 즉, 세마포는 공유 자원의 개수를 나타내는 변수이다. 

* **Binary semaphore** : 공유 자원이 1개인 경우, 자원을 사용할 수 없는 경우는 0, 사용할 수 있는 경우는 1의 값을 가진다. (Lock 과 비슷하나 값이 반대이다. Lock은 사용할 수 없는 경우에 1을 가진다.)

* **Counting semaphore** : 2이상의 값도 가질 수 있는 경우이다. 예를 들어, 서버에 프린트 기기가 5개가 연결되어 있을 때, 공유 자원인 프린터는 5개로 초기화 된다. 이 경우에서, 사용자가 동시에 사용하는 프린터 기기가 5개가 넘으면 그 다음 프린터 요청은 세마포가 0이니까 보류된다. 이는 후에 누군가가 프린터를 다 쓰고 반환할 때 까지 기다렸다가 처리 된다.

> 자원 & 반납 : 
>
> * wait() [세마포를 -1 하는 함수, 세마포가 0이면 기다리는 함수]
> * signal() [세마포를 +1 하는 함수, 세마포 사용했으니 돌려놓는 함수]

 

6. thread를 사용하는 이유는 무엇인지 설명하시오

* 시스템 작업을 효율적으로 관리하기 위해서다. 특히, 멀티 프로세스 작업을 멀티 스레드로 실행하면 자원을 할당할 필요 없이 한번 프로세스에 자원을 할당하면 스레드들 간 이 자원을 공유하여 사용하므로 프로세스를 Context Switching 하는 것 보다 오버헤드가 작다. 그리고, 여러 스레드 간 통신 비용이 프로세스간의 통신비용보다 작다.

 

참고

1. https://jhkang-tech.tistory.com/13

2. https://asfirstalways.tistory.com/99

3. https://gbsb.tistory.com/312

   https://jwprogramming.tistory.com/12

4. https://12bme.tistory.com/68

   https://jhnyang.tistory.com/35

5. https://jhnyang.tistory.com/36

   https://jhnyang.tistory.com/101

6. https://www.crocus.co.kr/1510