# Java

## 객체지향언어

객체지향언어 : robust, 유지보수가 강함 , 대신 절차지양언어 보다 프로그램 설계가 복잡

컴퓨터 프로그램을 '객체' 라는 단위로 나누고 이 객체들의 상호작용으로 서술하는 프로그래밍 패러다임이다. 각 `객체(Object)` 들은 서로 메세지를 주고 받을 수 있으며 데이터를 처리할 수 있다. 

OOP를 사용하면 코드의 중복을 어느 정도 줄일 수 있고 입력 코드, 계산 코드와 결과 출력 코드 등 코드의 역할 분담을 좀 더 확실하게 할 수 있어서 가독성이 높아질 수 있다.

GUI가 등장하면서, 화면에 떠 있는 여러 개의 창은 각자의 실행 콘텍스트를 가지는데 콘텍스트의 현재 상태(활성화, 비활성화, 최소화 등)에 따라 같은 명령에도 다른 결과를 내보내야 했으며 사용자 상호작용을 위해 이벤트 처리도 수행해야 했다. (ex 검색 버튼 클릭)

특히 이벤트 처리는 비동기적인 속성 때문에 기존 절차적 프로그래밍에서는 일종의 횡단 관심사가 되어 버려 코드 전체에 이벤트 처리 코드가 흩어져 있게 되는 문제가 있었다. 그래서 OOP를 도입하여 이벤트를 받았을 때 수행되는 기능(Event Handler, Callback)을 구현할 수 있는 단일 인터페이스를 정의하고, 프로그래머들은 이를 필요한 형태로 알아서 구현하며, 특정 이벤트가 일어났을 때 실행되어야 하는 기능들을 등록한 다음, 운영체제나 응용프로그램이 실제로 해당 이벤트가 발생했을 때 해당 이벤트에 등록된 이벤트 핸들러/콜백을 실행하기만 하면 되는 구조가 본격적으로 확산되면서 OOP 또한 빠르게 확산되었다.

객체 지향 프로그램이 복잡해지면서 이를 간결하게 정리할 필요성이 생긴 관계로 '[디자인 패턴](https://namu.wiki/w/디자인 패턴)'이라는 것이 생겼다. 프로그래밍 형식을 정하는 일종의 약속으로, 이는 특히 협업을 전제로 한 환경에서 특히 강조되고 있다.

#### Object

Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념

**Q1) Java 란 무엇인가?**

java는 JVM 을 지니고 있어, 어떤 OS에든 호환되어 잘 동작하는 특징이 있다. JVM은 컴파일 된 바이트 코드들을 각 OS에 맞는 기계언어로 변환 시켜준다. 따라서 운영체제에 관계없이 같은 코드를 사용할 수 있다.  또한 자바는 oop 개념 즉, 객체 지향적 언어이다.

**Q2) 객체지향언어의 특징, 장점은?**

프로그램을 객체 라는 것으로 나누고 이런 객체들의 상호작용으로 정의하는 것.  즉, 조각조각 구현한 객체들을 종합적으로 합쳐서 전체 결과물을 만드는 것이다. oop로 코드를 작성하면, 코드의 재사용성이 높고  유지보수에 용이하다. 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead 가 발생하게 된다. 하지만 이것은 하드웨어의 발전으로 많은 부분 보완되었다. 객체 지향 프로그래밍의 치명적인 단점은 함수형 프로그래밍 패러다임의 등장 배경을 통해서 알 수 있다. 바로 객체가 상태를 갖는다는 것이다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킨다는 것이다. 이러한 이유로 함수형 패러다임이 주목받고 있다. (?)

#### 인터페이스란?

클래스의 템플릿입니다. 인터페이스는 멤버 변수, 멤버 함수를 가질 수 없고, 추상 메소드만 가질 수 있습니다. 그러니까 말하자면 껍데기만 있는 클래스인거죠.

사용목적은 인터페이스라는 이름 뜻 그대로, 클래스를 사용함에 있어서 인터페이스를 제공하기 위함 입니다. 즉, **인터페이스는 여러 클래스의 사용 방법이 같음을 보장합니다.** 그렇기 때문에 자신을 implement 하는 클래스들에게 메서드 구현을 강제합니다.

예를들어 [List 인터페이스](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) 를 implement 하는 클래스 들인 ArrayList, LinkedList는 공통적으로 add(), clear(), indexOf(), get() 등의 메서드를 가지고 있습니다.

#### 추상 클래스란? 인터페이스와의 차이점은?

추상클래스란 abstract로 정의되거나, 클래스 내에 추상 메서드가 하나 이상 포함된 클래스입니다. 근본적인 차이점은 사용 목적입니다. 클래스는 기본적으로 상속을 통해 기능을 확장하려는 목적으로 사용하며, 인터페이스는 해당 인터페이스를 구현한 객체들에 대해 동일한 동작을 약속하게 하기 위해서 사용합니다. 이 외에 추상클래스는 다중상속이 불가능하고 인터페이스는 가능하다는 차이점도 있는데, 목적이 달라서 기능이 다른 것 뿐이지, 인터페이스는 다중상속을 보완하려고 존재하는게 아닙니다.

#### 특징 5가지

#### 메모리

1. static

   : static 영역의 데이터들은 프로그램의 시작부터 종료가 될 때까지 메모리에 저장된다. 

   : 하나의 JAVA 파일은 필드(field), 생성자(constructor), 메소드(method)로 구성 된다. 그중 필드 부분에서 선언된 변수(전역변수)와 정적 멤버 변수(static이 붙은 자료형)는 static 역역에 저장된다.

2. stack

   : 메소드 내에서 생성하는 기본 자료형 타입의 지역변수의 데이터가 저장되는 공간

   : 변수에 해당하는 메서드가 호출될 때 메모리에 할당되고 그 메서드가 종료되면 메모리에서 삭제된다.

3. heap

   : 참조형 데이터 타입의 객체, 배열 등이 저장되는 공간

   : Stack 영역에 저장된 변수 공간에는 실제 데이터가 저장된 heap영역의 시작 주소 (`참조값`)가 new 연산자를 통해 반환된다.

   : ex. A a = new A()일 때, stack은 주소값을, heap 은 해당 클래스의 데이터들을 저장

> 생명주기
>
> static > heap > stack

#### gc (garbage collection)

: Heap에 저장된 데이터가 더 이상 stack에 있는 변수로 부터 참조되지 않을 때(쓸모 없어 지는 경우), JVM이 알아서 메모리에서 해제 시키는 것 

: 이로 인해서 개발자가 따로 메모리 관리를 할 필요가 없다.

#### String, StringBuilder, StringBuffer 의 차이

- String

String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이 존재한다. 하지만 JDK 1.5 이후부터는 컴파일 타임에 StringBuilder로 변경한다고 한다.

- StringBuilder

String에서 + 등으로 문자열 등을 concat하는 연산이 많은 경우 사용하는것이 좋다. 기존 String 문자들을 concat하는 경우 매번 새로운 String 인스턴스를 사용하기 때문에 성능상의 이슈 존재(JDK 1.5버전 부터는 내부적으로 StringBuilder를 이용하도록 변경되긴 했다.)

- StringBuffer

StringBuffer는 Builder와 비교해서 thread-safe하다. (멀티 스레드 환경에서 동기화의 지원 여부가 다름.) 내부적으로 append 등 모든 메소드에 대해 synchronized 키워드가 붙어있다.

 : (String) 불변. 문자를 수정하려면 지우고 다시 생성(new) -> 문자열 연산이 많으면 성능 떨어짐

(StringBuffer)는 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경. append()처럼.

(StringBuilder) 동기화 지원x, 멀티쓰레드 환경에부적합. => 싱글쓰레드에서 stringBuffer 보다 좋음



**-** **성능을 개선하기 위해 어떤 방법을 사용?**

 static 사용 : 인스턴스 변수에 접근할 일이 없는 경우 static메서드를 선언하여 호출하면 15~20% 개선

(장) 모든 객체가 공유할 수 있음 메모리절약 + 연속적으로 그 값의 흐름을 이어갈 수 있음.

final 과 차이 : 변경할 수 없음, 상속할 수 없음

 Static + final : 변경할 수 없는 공유정보

## Comparable, Comparator 차이



Java 8 이후로 lamda

(a) -> {return a;}



# 참고

[나무위키_객체지향프로그래밍](https://namu.wiki/w/객체 지향 프로그래밍)

[Tistory_객체 지향에 대한 이해](https://asfirstalways.tistory.com/177)

[신입 개발자 면접 질문 (개발 일반 및 java)](https://hanee24.github.io/2018/05/13/interview-questions/)